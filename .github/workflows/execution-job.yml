name: execution-job
on:
  workflow_call:
    inputs:
      dry_run:
        description: 'Run in dry-run mode'
        required: false
        default: 'false'
        type: string
      target_domain:
        description: 'Target domain filter'
        required: false
        type: string
      campaign_filter:
        description: 'Campaign domain filter'
        required: false
        type: string
      skip_feedback_injection:
        description: 'Skip feedback injection'
        required: false
        default: 'false'
        type: string
      debug_mode:
        description: 'Enable debug mode'
        required: false
        default: 'false'
        type: string
      batch_size:
        description: 'Batch size for processing'
        required: false
        type: string
      batch_delay:
        description: 'Delay between batches in seconds'
        required: false
        default: '30'
        type: string
      enable_tracking:
        description: 'Enable email delivery tracking'
        required: false
        default: 'true'
        type: string
      contact_count:
        description: 'Number of contacts from validation'
        required: false
        default: '0'
        type: string
      campaign_count:
        description: 'Number of campaigns from validation'
        required: false
        default: '0'
        type: string
    outputs:
      execution_status:
        description: 'Campaign execution status'
        value: ${{ jobs.execute.outputs.status }}
      emails_sent:
        description: 'Number of emails sent'
        value: ${{ jobs.execute.outputs.sent }}
      campaigns_processed:
        description: 'Number of campaigns processed'
        value: ${{ jobs.execute.outputs.campaigns }}

env:
  CONTACTS_DIR: contacts
  SCHEDULED_DIR: campaigns
  ALERT_EMAIL: alerts@yourdomain.com
  FEEDBACK_EMAIL: feedback@yourdomain.com

jobs:
  execute:
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.execution-summary.outputs.status }}
      sent: ${{ steps.execution-summary.outputs.sent }}
      campaigns: ${{ steps.execution-summary.outputs.campaigns }}
      processed: ${{ steps.execution-summary.outputs.processed }}
      failed: ${{ steps.execution-summary.outputs.failed }}
    
    steps:
      - name: Checkout code
        uses: sednabcn/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pandas openpyxl google-api-python-client google-auth-httplib2 google-auth-oauthlib python-docx

      - name: Display execution parameters
        run: |
          echo "=== EXECUTION PARAMETERS ==="
          echo "Dry run: ${{ inputs.dry_run }}"
          echo "Target domain: ${{ inputs.target_domain }}"
          echo "Campaign filter: ${{ inputs.campaign_filter }}"
          echo "Batch size: ${{ inputs.batch_size }}"
          echo "Batch delay: ${{ inputs.batch_delay }}s"
          echo "Enable tracking: ${{ inputs.enable_tracking }}"
          echo "Contact count: ${{ inputs.contact_count }}"
          echo "Campaign count: ${{ inputs.campaign_count }}"
          echo "Skip feedback: ${{ inputs.skip_feedback_injection }}"
          echo "Debug mode: ${{ inputs.debug_mode }}"

      - name: Execute campaigns using utils/docx_parser.py
        env:
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
        run: |
          echo "Starting campaign execution using utils/docx_parser.py..."
          echo "Mode: ${{ inputs.dry_run == 'true' && 'DRY-RUN' || 'LIVE' }}"
          
          # Verify utils directory and required scripts exist
          if [ ! -d "utils" ]; then
            echo "❌ utils/ directory not found"
            exit 1
          fi
          
          if [ ! -f "utils/docx_parser.py" ]; then
            echo "❌ utils/docx_parser.py not found"
            exit 1
          fi
          
          if [ ! -f "utils/data_loader.py" ]; then
            echo "❌ utils/data_loader.py not found - required by docx_parser.py"
            exit 1
          fi
          
          echo "✅ Found required utils scripts:"
          echo "  - utils/docx_parser.py ($(wc -l < utils/docx_parser.py) lines)"
          echo "  - utils/data_loader.py ($(wc -l < utils/data_loader.py) lines)"
          
          # Setup Google credentials for Google Sheets access
          if [ -n "${{ secrets.GOOGLE_SVC_JSON }}" ]; then
            echo "${{ secrets.GOOGLE_SVC_JSON }}" | base64 -d > /tmp/google_svc.json
            chmod 600 /tmp/google_svc.json
            echo "GOOGLE_APPLICATION_CREDENTIALS=/tmp/google_svc.json" >> $GITHUB_ENV
            echo "✅ Google credentials configured for utils/data_loader.py"
          fi
          
          # Create directory structure expected by utils/docx_parser.py
          mkdir -p contacts campaigns scheduled-campaigns templates tracking logs reports
          
          # Link to actual directory structure if different names
          if [ -d "${{ env.CONTACTS_DIR }}" ] && [ "${{ env.CONTACTS_DIR }}" != "contacts" ]; then
            echo "Linking ${{ env.CONTACTS_DIR }} to contacts/ for utils/docx_parser.py"
            rm -rf contacts
            ln -sf "$PWD/${{ env.CONTACTS_DIR }}" contacts
          fi
          
          if [ -d "${{ env.SCHEDULED_DIR }}" ] && [ "${{ env.SCHEDULED_DIR }}" != "campaigns" ]; then
            echo "Linking ${{ env.SCHEDULED_DIR }} to campaigns/ for utils/docx_parser.py"
            rm -rf campaigns  
            ln -sf "$PWD/${{ env.SCHEDULED_DIR }}" campaigns
          fi
          
          # Build arguments for utils/docx_parser.py
          DOCX_ARGS=(
            "--contacts" "$(pwd)/contacts"
            "--scheduled" "$(pwd)/campaigns"
            "--tracking" "$(pwd)/tracking"
            "--alerts" "${{ env.ALERT_EMAIL }}"
            "--feedback" "${{ env.FEEDBACK_EMAIL }}"
          )
          
          # Add workflow input arguments - using inputs instead of github.event.inputs
          if [ "${{ inputs.dry_run }}" == "true" ]; then
            DOCX_ARGS+=("--dry-run")
            echo "DRY-RUN mode enabled"
          fi
          
          if [ -n "${{ inputs.target_domain }}" ]; then
            DOCX_ARGS+=("--domain" "${{ inputs.target_domain }}")
            echo "Target domain: ${{ inputs.target_domain }}"
          fi
          
          if [ -n "${{ inputs.campaign_filter }}" ]; then
            DOCX_ARGS+=("--filter-domain" "${{ inputs.campaign_filter }}")
            echo "Campaign filter: ${{ inputs.campaign_filter }}"
          fi
          
          if [ "${{ inputs.skip_feedback_injection }}" != "true" ]; then
            echo "Feedback injection enabled"
          else
            DOCX_ARGS+=("--no-feedback")
            echo "Feedback injection disabled"
          fi
          
          if [ "${{ inputs.debug_mode }}" == "true" ]; then
            DOCX_ARGS+=("--debug")
            echo "Debug mode enabled"
          fi
          
          # Handle new batch processing inputs
          if [ -n "${{ inputs.batch_size }}" ]; then
            echo "Batch size requested: ${{ inputs.batch_size }}"
            # Add to args if docx_parser.py supports it
          fi
          
          if [ -n "${{ inputs.batch_delay }}" ]; then
            echo "Batch delay configured: ${{ inputs.batch_delay }}s"
            # Implement delay between batches if supported
          fi
          
          if [ "${{ inputs.enable_tracking }}" == "true" ]; then
            echo "Email tracking enabled"
            # Add tracking flags if supported by docx_parser.py
          fi
          
          echo ""
          echo "Executing utils/docx_parser.py with arguments:"
          printf '%s\n' "${DOCX_ARGS[@]}"
          echo ""
          
          # Set Python path to include utils directory
          export PYTHONPATH="$PWD/utils:$PYTHONPATH"
          
          # Execute utils/docx_parser.py with proper argument handling
          cd utils
          python docx_parser.py \
            --contacts "../contacts" \
            --scheduled "../campaigns" \
            --tracking "../tracking" \
            --alerts "${{ env.ALERT_EMAIL }}" \
            --feedback "${{ env.FEEDBACK_EMAIL }}" \
            $( [ "${{ inputs.dry_run }}" == "true" ] && echo "--dry-run" || echo "" ) \
            $( [ -n "${{ inputs.target_domain }}" ] && echo "--domain ${{ inputs.target_domain }}" || echo "" ) \
            $( [ -n "${{ inputs.campaign_filter }}" ] && echo "--filter-domain ${{ inputs.campaign_filter }}" || echo "" ) \
            $( [ "${{ inputs.skip_feedback_injection }}" == "true" ] && echo "--no-feedback" || echo "" ) \
            $( [ "${{ inputs.debug_mode }}" == "true" ] && echo "--debug" || echo "" ) \
            2>&1 | tee ../execution.log
          
          EXECUTION_STATUS=$?
          cd ..
          
          echo ""
          echo "utils/docx_parser.py execution completed with status: $EXECUTION_STATUS"
          echo "EXECUTION_STATUS=$EXECUTION_STATUS" >> $GITHUB_ENV

      - name: Generate execution summary
        id: execution-summary
        run: |
          echo "=== GENERATING EXECUTION SUMMARY ==="
          
          python << 'EOF'
          import os
          import sys
          import json
          import re
          from pathlib import Path
          from datetime import datetime
          
          # Initialize metrics
          processed_count = 0
          sent_count = 0
          failed_count = 0
          campaigns_processed = 0
          
          # Check for execution logs created by utils/docx_parser.py
          log_files = ['execution.log', 'dryrun.log', 'campaign_execution.log']
          results_found = False
          
          print("Checking for execution logs...")
          for log_file in log_files:
              if Path(log_file).exists():
                  print(f"Found execution log: {log_file}")
                  results_found = True
                  
                  try:
                      with open(log_file, 'r') as f:
                          log_content = f.read()
                      
                      # Parse log content for metrics
                      lines = log_content.split('\n')
                      for line in lines:
                          # Look for contact patterns
                          if any(phrase in line.lower() for phrase in ['contacts loaded', 'total contacts', 'loaded contacts']):
                              numbers = re.findall(r'\d+', line)
                              if numbers:
                                  processed_count = max(processed_count, int(numbers[0]))
                          
                          # Look for campaign patterns
                          elif any(phrase in line.lower() for phrase in ['campaigns processed', 'campaign:', 'processing campaign']):
                              campaigns_processed += 1
                          
                          # Look for email patterns
                          elif any(phrase in line.lower() for phrase in ['sent:', 'emails sent', 'successfully sent']):
                              numbers = re.findall(r'\d+', line)
                              if numbers:
                                  sent_count = max(sent_count, int(numbers[0]))
                          
                          # Look for failures
                          elif any(phrase in line.lower() for phrase in ['failed:', 'error:', 'failed to send']):
                              failed_count += 1
                      
                      print(f"Extracted from {log_file}:")
                      print(f"  Contacts processed: {processed_count}")
                      print(f"  Campaigns processed: {campaigns_processed}")  
                      print(f"  Emails sent: {sent_count}")
                      print(f"  Failures detected: {failed_count}")
                      break
                      
                  except Exception as e:
                      print(f"Error parsing {log_file}: {e}")
          
          # Use validation inputs as fallback
          if not results_found or processed_count == 0:
              try:
                  contact_count = int('${{ inputs.contact_count }}' or '0')
                  campaign_count = int('${{ inputs.campaign_count }}' or '0')
                  
                  if contact_count > 0:
                      processed_count = contact_count
                      campaigns_processed = campaign_count
                      print(f"Using validation counts - Contacts: {processed_count}, Campaigns: {campaigns_processed}")
                      
                      # In dry-run mode, assume success
                      if '${{ inputs.dry_run }}' == 'true':
                          sent_count = processed_count
                          print(f"DRY-RUN mode: marked {sent_count} as successfully processed")
              except Exception as e:
                  print(f"Error using validation counts: {e}")
          
          # Determine final status
          if failed_count == 0 and processed_count > 0:
              final_status = 'success'
          elif sent_count > 0:
              final_status = 'partial'
          else:
              final_status = 'failed'
          
          # Set GitHub outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"processed={processed_count}\n")
              f.write(f"sent={sent_count}\n")
              f.write(f"failed={failed_count}\n")
              f.write(f"campaigns={campaigns_processed}\n")
              f.write(f"status={final_status}\n")
          
          print(f"\n=== FINAL EXECUTION SUMMARY ===")
          print(f"Contacts processed: {processed_count}")
          print(f"Campaigns executed: {campaigns_processed}")
          print(f"Emails sent: {sent_count}")
          print(f"Failures: {failed_count}")
          print(f"Status: {final_status}")
          if processed_count > 0:
              print(f"Success rate: {(sent_count/processed_count*100):.1f}%")
          EOF
