name: Cleanup Old Workflow Runs
on:
  schedule:
    - cron: '0 2 * * 0'  # Every Sunday at 02:00 UTC
  workflow_dispatch:

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      actions: write
      contents: read
    steps:
      - name: Cleanup Old Workflow Runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN}}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Configuration - ULTRA aggressive cleanup
            const KEEP_RECENT_RUNS = 3;   // Keep only 3 runs per workflow MAX
            const KEEP_DAYS = 3;          // Keep runs from last 3 days only  
            const MAX_TOTAL_RUNS = 25;    // STRICT global limit
            const MAX_PAGES = 30;         // Increase to catch all runs
            
            console.log('üßπ Starting ULTRA aggressive workflow cleanup...');
            console.log(`Policy: STRICT limit of ${MAX_TOTAL_RUNS} runs total (max ${KEEP_RECENT_RUNS} per workflow)`);
            console.log(`Priority given to runs from last ${KEEP_DAYS} days`);
            console.log(`Repository: ${owner}/${repo}`);
            console.log('================================');
            
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - KEEP_DAYS);
            console.log(`Cutoff date: ${cutoffDate.toISOString()}`);
            
            let totalDeleted = 0;
            let totalKept = 0;
            let totalProcessed = 0;
            let workflowCount = 0;
            let allRunsAcrossWorkflows = []; // Track all runs globally
            
            try {
              // First pass: collect ALL runs from ALL workflows
              console.log('üìã Getting workflows...');
              const { data: workflowsData } = await github.rest.actions.listRepoWorkflows({
                owner,
                repo
              });
              
              const workflows = workflowsData.workflows;
              workflowCount = workflows.length;
              console.log(`Found ${workflowCount} workflows`);
              
              // Collect all runs first
              for (const workflow of workflows) {
                console.log(`\nüîç Collecting runs from: ${workflow.name} (ID: ${workflow.id})`);
                
                let page = 1;
                while (page <= MAX_PAGES) {
                  try {
                    console.log(`  üìñ Fetching page ${page} for ${workflow.name}...`);
                    const { data: runsPage } = await github.rest.actions.listWorkflowRuns({
                      owner,
                      repo,
                      workflow_id: workflow.id,
                      page,
                      per_page: 100
                    });
                    
                    console.log(`    üìä Got ${runsPage.workflow_runs.length} runs on page ${page}`);
                    
                    if (runsPage.workflow_runs.length === 0) break;
                    
                    // Add workflow info to each run
                    const runsWithWorkflow = runsPage.workflow_runs.map(run => ({
                      ...run,
                      workflow_name: workflow.name,
                      workflow_id: workflow.id
                    }));
                    
                    allRunsAcrossWorkflows = allRunsAcrossWorkflows.concat(runsWithWorkflow);
                    console.log(`    üìà Total runs collected so far: ${allRunsAcrossWorkflows.length}`);
                    
                    page++;
                    await new Promise(resolve => setTimeout(resolve, 100));
                  } catch (error) {
                    console.log(`    ‚ùå Error fetching runs from ${workflow.name}: ${error.message}`);
                    console.log(`    üìä Error details: ${JSON.stringify(error, null, 2)}`);
                    break;
                  }
                }
              }
              
              totalProcessed = allRunsAcrossWorkflows.length;
              console.log(`\nüìä Total runs collected: ${totalProcessed}`);
              
              // Sort ALL runs by creation date (newest first)
              allRunsAcrossWorkflows.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              
              // Apply global policies
              const runsToKeep = [];
              const runsToDelete = [];
              const workflowRunCounts = {};
              
              for (let i = 0; i < allRunsAcrossWorkflows.length; i++) {
                const run = allRunsAcrossWorkflows[i];
                const runDate = new Date(run.created_at);
                const workflowId = run.workflow_id;
                
                // Count runs per workflow
                if (!workflowRunCounts[workflowId]) {
                  workflowRunCounts[workflowId] = 0;
                }
                
                const isWithinDays = runDate > cutoffDate;
                const isWithinWorkflowLimit = workflowRunCounts[workflowId] < KEEP_RECENT_RUNS;
                const isWithinGlobalLimit = runsToKeep.length < MAX_TOTAL_RUNS;
                
                // STRICT global limit - only keep if within global limit
                // Priority: recent runs within workflow limits, but NEVER exceed global limit
                if (isWithinGlobalLimit && (isWithinDays || isWithinWorkflowLimit)) {
                  runsToKeep.push(run);
                  workflowRunCounts[workflowId]++;
                } else {
                  runsToDelete.push(run);
                }
              }
              
              console.log(`\nüìä Final decision:`);
              console.log(`  üì¶ Will keep: ${runsToKeep.length} runs`);
              console.log(`  üóëÔ∏è  Will delete: ${runsToDelete.length} runs`);
              
              // Group deletions by workflow for organized processing
              const deletesByWorkflow = {};
              for (const run of runsToDelete) {
                if (!deletesByWorkflow[run.workflow_id]) {
                  deletesByWorkflow[run.workflow_id] = [];
                }
                deletesByWorkflow[run.workflow_id].push(run);
              }
              
              // Process deletions by workflow
              
              for (const [workflowId, runs] of Object.entries(deletesByWorkflow)) {
                const workflowName = runs[0].workflow_name;
                console.log(`\nüóëÔ∏è  Deleting ${runs.length} runs from: ${workflowName}`);
                
                // Delete in batches
                const BATCH_SIZE = 5;
                let workflowDeleted = 0;
                
                for (let i = 0; i < runs.length; i += BATCH_SIZE) {
                  const batch = runs.slice(i, i + BATCH_SIZE);
                  console.log(`    üóëÔ∏è  Batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(runs.length/BATCH_SIZE)} (${batch.length} runs)`);
                  
                  const deletePromises = batch.map(async (run) => {
                    try {
                      await github.rest.actions.deleteWorkflowRun({
                        owner,
                        repo,
                        run_id: run.id
                      });
                      return true;
                    } catch (error) {
                      console.log(`      ‚ùå Failed to delete run ${run.id}: ${error.message}`);
                      return false;
                    }
                  });
                  
                  const results = await Promise.allSettled(deletePromises);
                  const successful = results.filter(r => r.status === 'fulfilled' && r.value).length;
                  workflowDeleted += successful;
                  
                  // Delay between batches
                  if (i + BATCH_SIZE < runs.length) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                  }
                }
                
                console.log(`  üìä Deleted ${workflowDeleted}/${runs.length} runs from ${workflowName}`);
                totalDeleted += workflowDeleted;
              }
              
              totalKept = runsToKeep.length;
              
            } catch (error) {
              console.error('‚ùå Fatal error during cleanup:', error.message);
              throw error;
            }
            
            console.log('\n=================================');
            console.log('üéâ Cleanup completed!');
            console.log('üìä Total summary:');
            console.log(`  ‚Ä¢ Workflows processed: ${workflowCount}`);
            console.log(`  ‚Ä¢ Total runs processed: ${totalProcessed}`);
            console.log(`  ‚Ä¢ Runs kept: ${totalKept}`);
            console.log(`  ‚Ä¢ Runs deleted: ${totalDeleted}`);
            console.log(`  ‚Ä¢ Success rate: ${totalProcessed > 0 ? Math.round((totalDeleted + totalKept) / totalProcessed * 100) : 0}%`);
            
            // Create issue with summary if significant cleanup happened
            if (totalDeleted > 10) {
              const issueBody = [
                '## Workflow Cleanup Results',
                '',
                `**Date:** ${new Date().toISOString()}`,
                `**Repository:** ${owner}/${repo}`,
                '',
                '### Summary',
                `- **Workflows processed:** ${workflowCount}`,
                `- **Total runs processed:** ${totalProcessed}`,
                `- **Runs kept:** ${totalKept}`,
                `- **Runs deleted:** ${totalDeleted}`,
                '',
                '### Policy Applied',
                `- STRICT limit: Max ${MAX_TOTAL_RUNS} runs total across ALL workflows`,
                `- Per-workflow limit: Max ${KEEP_RECENT_RUNS} runs per workflow`,
                `- Priority: Runs from last ${KEEP_DAYS} days get preference`,
                `- Processed up to ${MAX_PAGES} pages per workflow`,
                '',
                '### Status',
                '‚úÖ Cleanup completed successfully'
              ].join('\n');
              
              await github.rest.issues.create({
                owner,
                repo,
                title: `üßπ Workflow Cleanup Summary - ${new Date().toISOString().split('T')[0]}`,
                body: issueBody,
                labels: ['maintenance', 'automated']
              });
            }
         } catch (error) {
            console.error('‚ùå Fatal error during cleanup:', error.message);
            console.error('Stack trace:', error.stack);
            
            // Still try to create an error issue
            try {
              await github.rest.issues.create({
                owner,
                repo,
                title: `‚ùå Workflow Cleanup Failed - ${new Date().toISOString().split('T')[0]}`,
                body: [
                  '## Workflow Cleanup Error',
                  '',
                  `**Date:** ${new Date().toISOString()}`,
                  `**Repository:** ${owner}/${repo}`,
                  '',
                  '### Error Details',
                  '```',
                  error.message,
                  '```',
                  '',
                  '### Statistics Before Failure',
                  `- Workflows processed: ${workflowCount}`,
                  `- Runs processed: ${totalProcessed}`,
                  `- Runs deleted: ${totalDeleted}`,
                  `- Runs kept: ${totalKept}`,
                  '',
                  '‚ö†Ô∏è Please check the workflow logs for more details.'
                ].join('\n'),
                labels: ['maintenance', 'automated', 'error']
              });
            } catch (issueError) {
              console.error('‚ùå Could not create error issue:', issueError.message);
            }
            
            throw error;
          }
