name: Delete All Old Workflow Runs
on:
  push:
    branches: ["dev", "main", "master"]

  schedule:
    - cron: '0 2 * * 0'  # Every Sunday at 02:00 UTC
  workflow_dispatch:

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      actions: write
      contents: read
    steps:
      - name: Delete All Old and Failed Workflow Runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN}}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Configuration - AGGRESSIVE cleanup of old and failed runs
            const KEEP_RECENT_RUNS = 3;   // Keep only 3 most recent successful runs per workflow
            const KEEP_DAYS = 2;          // Delete everything older than 2 days
            const MAX_PAGES = 50;         // Process more pages to catch all runs
            const DELETE_OLD_EVEN_IF_SUCCESSFUL = true; // Delete old runs even if successful
            
            console.log('üßπ Starting AGGRESSIVE workflow cleanup...');
            console.log(`Policy: Delete ALL failed runs and old runs (older than ${KEEP_DAYS} days)`);
            console.log(`Keep: Only ${KEEP_RECENT_RUNS} most recent successful runs per workflow`);
            console.log(`Repository: ${owner}/${repo}`);
            console.log('================================');
            
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - KEEP_DAYS);
            console.log(`Cutoff date: ${cutoffDate.toISOString()}`);
            
            let totalDeleted = 0;
            let totalKept = 0;
            let totalProcessed = 0;
            let workflowCount = 0;
            let failedDeleted = 0;
            let oldDeleted = 0;
            
            try {
              console.log('üìã Getting workflows...');
              const { data: workflowsData } = await github.rest.actions.listRepoWorkflows({
                owner,
                repo
              });
              
              const workflows = workflowsData.workflows;
              workflowCount = workflows.length;
              console.log(`Found ${workflowCount} workflows`);
              
              // Process each workflow
              for (const workflow of workflows) {
                console.log(`\nüîç Processing: ${workflow.name} (ID: ${workflow.id})`);
                
                let allRuns = [];
                let page = 1;
                
                // Collect all runs for this workflow
                while (page <= MAX_PAGES) {
                  try {
                    const { data: runsPage } = await github.rest.actions.listWorkflowRuns({
                      owner,
                      repo,
                      workflow_id: workflow.id,
                      page,
                      per_page: 100
                    });
                    
                    if (runsPage.workflow_runs.length === 0) break;
                    
                    allRuns = allRuns.concat(runsPage.workflow_runs);
                    console.log(`  üìä Collected ${allRuns.length} total runs so far...`);
                    
                    page++;
                    await new Promise(resolve => setTimeout(resolve, 100));
                  } catch (error) {
                    console.log(`  ‚ùå Error fetching runs: ${error.message}`);
                    break;
                  }
                }
                
                totalProcessed += allRuns.length;
                
                // Separate runs by age and status
                const runsToKeep = [];
                const runsToDelete = [];
                
                for (const run of allRuns) {
                  const runDate = new Date(run.created_at);
                  const isOld = runDate < cutoffDate;
                  const isFailed = run.conclusion !== 'success';
                  
                  // FIXED: Clear priority order for deletion
                  if (isFailed) {
                    // Always delete failed runs
                    runsToDelete.push(run);
                    failedDeleted++;
                  } else if (isOld && DELETE_OLD_EVEN_IF_SUCCESSFUL) {
                    // Delete old runs even if successful
                    runsToDelete.push(run);
                    oldDeleted++;
                  } else {
                    // Keep recent successful runs
                    runsToKeep.push(run);
                  }
                }
                
                // Sort runs to keep by date (newest first)
                runsToKeep.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                
                // If we have more than KEEP_RECENT_RUNS, delete the extras
                if (runsToKeep.length > KEEP_RECENT_RUNS) {
                  const excessRuns = runsToKeep.slice(KEEP_RECENT_RUNS);
                  for (const run of excessRuns) {
                    runsToDelete.push(run);
                    oldDeleted++;
                  }
                  runsToKeep.splice(KEEP_RECENT_RUNS);
                }
                
                console.log(`  üìä Analysis for ${workflow.name}:`);
                console.log(`    ‚Ä¢ Total runs: ${allRuns.length}`);
                console.log(`    ‚Ä¢ Failed/Old runs to delete: ${runsToDelete.length}`);
                console.log(`    ‚Ä¢ Recent successful runs to keep: ${runsToKeep.length}`);
                
                // Delete runs in batches
                if (runsToDelete.length > 0) {
                  const BATCH_SIZE = 10;
                  let workflowDeleted = 0;
                  
                  for (let i = 0; i < runsToDelete.length; i += BATCH_SIZE) {
                    const batch = runsToDelete.slice(i, i + BATCH_SIZE);
                    console.log(`  üóëÔ∏è  Deleting batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(runsToDelete.length/BATCH_SIZE)}...`);
                    
                    const deletePromises = batch.map(async (run) => {
                      try {
                        await github.rest.actions.deleteWorkflowRun({
                          owner,
                          repo,
                          run_id: run.id
                        });
                        
                        return true;
                      } catch (error) {
                        console.log(`    ‚ùå Failed to delete run ${run.id}: ${error.message}`);
                        return false;
                      }
                    });
                    
                    const results = await Promise.allSettled(deletePromises);
                    const successful = results.filter(r => r.status === 'fulfilled' && r.value).length;
                    workflowDeleted += successful;
                    
                    // Delay between batches to avoid rate limits
                    if (i + BATCH_SIZE < runsToDelete.length) {
                      await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                  }
                  
                  console.log(`  ‚úÖ Deleted ${workflowDeleted}/${runsToDelete.length} runs from ${workflow.name}`);
                  totalDeleted += workflowDeleted;
                }
                
                totalKept += runsToKeep.length;
              }
              
              console.log('\n=================================');
              console.log('üéâ Cleanup completed!');
              console.log('üìä Final summary:');
              console.log(`  ‚Ä¢ Workflows processed: ${workflowCount}`);
              console.log(`  ‚Ä¢ Total runs processed: ${totalProcessed}`);
              console.log(`  ‚Ä¢ Runs kept: ${totalKept}`);
              console.log(`  ‚Ä¢ Runs deleted: ${totalDeleted}`);
              console.log(`    - Failed runs deleted: ${failedDeleted}`);
              console.log(`    - Old runs deleted: ${oldDeleted}`);
              console.log(`  ‚Ä¢ Success rate: ${totalProcessed > 0 ? Math.round((totalDeleted + totalKept) / totalProcessed * 100) : 0}%`);
              
              // Create summary issue
              if (totalDeleted > 0) {
                const issueBody = [
                  '## Workflow Cleanup Results',
                  '',
                  `**Date:** ${new Date().toISOString()}`,
                  `**Repository:** ${owner}/${repo}`,
                  '',
                  '### Summary',
                  `- **Workflows processed:** ${workflowCount}`,
                  `- **Total runs processed:** ${totalProcessed}`,
                  `- **Runs kept:** ${totalKept}`,
                  `- **Runs deleted:** ${totalDeleted}`,
                  `  - Failed runs: ${failedDeleted}`,
                  `  - Old runs: ${oldDeleted}`,
                  '',
                  '### Policy Applied',
                  `- ‚ùå Deleted ALL failed workflow runs`,
                  `- ‚ùå Deleted ALL runs older than ${KEEP_DAYS} days`,
                  `- ‚úÖ Kept only ${KEEP_RECENT_RUNS} most recent successful runs per workflow`,
                  '',
                  '### Status',
                  '‚úÖ Aggressive cleanup completed successfully'
                ].join('\n');
                
                await github.rest.issues.create({
                  owner,
                  repo,
                  title: `üßπ Workflow Cleanup Summary - ${new Date().toISOString().split('T')[0]}`,
                  body: issueBody,
                  labels: ['maintenance', 'automated', 'cleanup']
                });
                
                console.log('üìù Created summary issue');
              }
              
            } catch (error) {
              console.error('‚ùå Fatal error during cleanup:', error.message);
              console.error('Stack trace:', error.stack);
              
              // Create error issue
              try {
                await github.rest.issues.create({
                  owner,
                  repo,
                  title: `‚ùå Workflow Cleanup Failed - ${new Date().toISOString().split('T')[0]}`,
                  body: [
                    '## Workflow Cleanup Error',
                    '',
                    `**Date:** ${new Date().toISOString()}`,
                    `**Repository:** ${owner}/${repo}`,
                    '',
                    '### Error Details',
                    '```',
                    error.message,
                    '```',
                    '',
                    '### Statistics Before Failure',
                    `- Workflows processed: ${workflowCount}`,
                    `- Runs processed: ${totalProcessed}`,
                    `- Runs deleted: ${totalDeleted}`,
                    `- Failed runs deleted: ${failedDeleted}`,
                    `- Old runs deleted: ${oldDeleted}`,
                    `- Runs kept: ${totalKept}`,
                    '',
                    '‚ö†Ô∏è Please check the workflow logs for more details.'
                  ].join('\n'),
                  labels: ['maintenance', 'automated', 'error']
                });
              } catch (issueError) {
                console.error('‚ùå Could not create error issue:', issueError.message);
              }
              
              throw error;
            }
